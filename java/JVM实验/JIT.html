<html lang="en"><head>
    <meta charset="UTF-8">
    <title></title>
<style>#BAIDU_DSPUI_FLOWBAR,.adsbygoogle,.ad,div[class^="ad-widsget"],div[id^="div-gpt-ad-"],a[href*="@"][href*=".exe"],a[href*="/?/"][href*=".exe"],.adpushwin{display:none !important;}</style><style id="system" type="text/css">h1,h2,h3,h4,h5,h6,p,blockquote {    margin: 0;    padding: 0;}body {    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;    font-size: 13px;    line-height: 18px;    color: #737373;    margin: 10px 13px 10px 13px;}a {    color: #0069d6;}a:hover {    color: #0050a3;    text-decoration: none;}a img {    border: none;}p {    margin-bottom: 9px;}h1,h2,h3,h4,h5,h6 {    color: #404040;    line-height: 36px;}h1 {    margin-bottom: 18px;    font-size: 30px;}h2 {    font-size: 24px;}h3 {    font-size: 18px;}h4 {    font-size: 16px;}h5 {    font-size: 14px;}h6 {    font-size: 13px;}hr {    margin: 0 0 19px;    border: 0;    border-bottom: 1px solid #ccc;}blockquote {    padding: 13px 13px 21px 15px;    margin-bottom: 18px;    font-family:georgia,serif;    font-style: italic;}blockquote:before {    content:"C";    font-size:40px;    margin-left:-10px;    font-family:georgia,serif;    color:#eee;}blockquote p {    font-size: 14px;    font-weight: 300;    line-height: 18px;    margin-bottom: 0;    font-style: italic;}code, pre {    font-family: Monaco, Andale Mono, Courier New, monospace;}code {    background-color: #fee9cc;    color: rgba(0, 0, 0, 0.75);    padding: 1px 3px;    font-size: 12px;    -webkit-border-radius: 3px;    -moz-border-radius: 3px;    border-radius: 3px;}pre {    display: block;    padding: 14px;    margin: 0 0 18px;    line-height: 16px;    font-size: 11px;    border: 1px solid #d9d9d9;    white-space: pre-wrap;    word-wrap: break-word;}pre code {    background-color: #fff;    color:#737373;    font-size: 11px;    padding: 0;}@media screen and (min-width: 768px) {    body {        width: 748px;        margin:10px auto;    }}</style><style id="custom" type="text/css"></style></head>
<body><h1>JIT</h1>
<h2>开启JIT编译</h2>
<p>使用<code>java -version</code>可以查看JVM的执行模式，鄙人的计算机如下所示

</p>
<p>C:\Users\PC-Clive&gt;java -version
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)


</p>
<p>使用<code>-Xint</code>开启解释执行模式，使用<code>-Xcomp</code>开启编译执行模式，一般来说，
编译执行模式的执行效率会远远高于解释执行模式


</p>
<h2>源码</h2>
<pre><code class="lang-java">package test;
import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test&lt;E&gt; {

    private static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws NoSuchMethodException, SecurityException, ClassNotFoundException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        foo();
    }

    private static void foo() {

        Timer t = new Timer().start();
        for(int i=0;i&lt;100000;i++) {
            cal();
        }
        System.out.println(t.end());
    }

    private static void cal() {

        for(int i=0;i&lt;10000;i++) {
            double j = Math.PI/(Math.PI+1);
        }
    }
}</code></pre>
<h2>VM arguments</h2>
<p>-XX:+PrintCommandLineFlags
-Xcomp

</p>
<h2>console</h2>
<p>使用编译执行模式：3932817
使用解释执行模式：9931917437
使用混合执行模式（缺省）：4667769

</p>
<p>有控制太的输出可以看出，编译执行模式与解释执行模式相比高出了3个数量级


</p>
<h2>JIT编译阈值</h2>
<p>虚拟机默认的执行模式是混合模式，其内部有一个称为<code>编译阈值（compile threshold）</code>
的参数，当函数的调用次数超过这个编译阈值（Client模式下是1500次，Server模式下是10000次），就会被认为是热点代码，进行即使编译。
使用参数<code>-XX:CompileThreshold</code>可以设置这个阈值，使用<code>-XX:+PrintCompilation</code>可以
出相关日志

</p>
<h2>源码</h2>
<pre><code class="lang-java">package test;
import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test&lt;E&gt; {

    private static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        for(int i=0;i&lt;300;i++) {
            foo();
        }
        Thread.sleep(1000);
    }

    private static void foo() {

        int a = 0;
        int b = 0;
        int c = a+b;
    }

}</code></pre>
<h2>VM arguments</h2>
<p>-XX:+PrintCommandLineFlags
-XX:+PrintCompilation


</p>
<h2>console</h2>
<pre><code>-XX:InitialHeapSize=199409856 -XX:MaxHeapSize=3190557696 -XX:+PrintCommandLineFlags -XX:+PrintCompilation -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
    104    1       3       java.lang.String::hashCode (55 bytes)
    105    2       3       java.lang.String::equals (81 bytes)
    105    3       4       java.lang.String::charAt (29 bytes)
    109    4       3       java.lang.String::indexOf (70 bytes)
    110    5       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (16 bytes)
    110    6       3       java.lang.Object::&lt;init&gt; (1 bytes)
    110    7       3       java.lang.Character::toLowerCase (9 bytes)
    110   11       4       java.lang.String::length (6 bytes)
    110    8       3       java.lang.CharacterData::of (120 bytes)
    110    9       3       java.lang.CharacterDataLatin1::toLowerCase (39 bytes)
    110   13     n 0       java.lang.System::arraycopy (native)   (static)
    111   10       3       java.lang.CharacterDataLatin1::getProperties (11 bytes)
    111   12       3       java.lang.Math::min (11 bytes)
    111   14  s    3       java.lang.StringBuffer::append (13 bytes)
    111   17       1       java.lang.Object::&lt;init&gt; (1 bytes)
    111    6       3       java.lang.Object::&lt;init&gt; (1 bytes)   made not entrant
    111   15       3       java.io.WinNTFileSystem::isSlash (18 bytes)
    111   16       3       java.lang.AbstractStringBuilder::append (29 bytes)
    117   18       3       test.Test::foo (9 bytes)</code></pre>
<p>不知道为什么，<code>-XX:CompileThreshold</code>不起作用


</p>
<h2>内联优化</h2>
<p>方法内联是指，将用方法体替换方法调用，从而减少方法调用带来的性能损耗，JIT编译器默认会进行
内联优化。


</p>
<h2>源码</h2>
<pre><code class="lang-java">package test;

import java.lang.reflect.InvocationTargetException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test&lt;E&gt; {

    private static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {

        Timer timer = new Timer().start();
        for(int i=0;i&lt;1000000;i++) {
            inc();
        }
        System.out.println(timer.end());
    }

    private static void inc() {
        int i = 0;
        i++;
    }
}</code></pre>
<h2>VM arguments</h2>
<p>-XX:+PrintCommandLineFlags
-Xcomp
-server
-XX:+Inline //开启内联优化

</p>
<h2>console</h2>
<pre><code>开启内联优化
-XX:InitialHeapSize=199409856 -XX:-Inline -XX:MaxHeapSize=3190557696 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
1892547

关闭内联优化
-XX:InitialHeapSize=199409856 -XX:-Inline -XX:MaxHeapSize=3190557696 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
5711730</code></pre>
<p>与大多数优化策略一样，内联优化也是一把双刃剑，它的坏处体现在面对比较大的方法时，
它会因为内联而增大整个应用程序的方法体从而影响性能。通过参数<code>XX:FreqInlintSize</code>参数，指定
内联方法的大小上限，当方法超过指定的大小时，就不内联对应的方法









</p>
<p>Edit By <a href="http://mahua.jser.me">MaHua</a></p>
</body></html>